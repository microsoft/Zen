// <copyright file="ZenGenerator.cs" company="Microsoft">
// Copyright (c) Microsoft. All rights reserved.
// </copyright>

namespace ZenLib.Generators
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.Text;

    /// <summary>
    /// Generator for Zen methods for a given type.
    /// </summary>
    [Generator]
    public class ZenGenerator : ISourceGenerator
    {
        /// <summary>
        /// Initialize the generator.
        /// </summary>
        /// <param name="context">The initialization context.</param>
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        /// <summary>
        /// Execute the generator.
        /// </summary>
        /// <param name="context">The execution context.</param>
        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
            {
                return;
            }

            var zenObjectAttributeSymbol = context.Compilation.GetTypeByMetadataName($"ZenLib.ZenObjectAttribute");

            var namedTypedSymbols = new List<INamedTypeSymbol>();

            foreach (var candidateClass in receiver.ClassesWithAttributes)
            {
                var model = context.Compilation.GetSemanticModel(candidateClass.SyntaxTree);
                namedTypedSymbols.Add(model.GetDeclaredSymbol(candidateClass));
            }

            foreach (var candidateStruct in receiver.StructsWithAttributes)
            {
                var model = context.Compilation.GetSemanticModel(candidateStruct.SyntaxTree);
                namedTypedSymbols.Add(model.GetDeclaredSymbol(candidateStruct));
            }

            foreach (var typedSymbol in namedTypedSymbols)
            {
                var hasZenObjectAttribute = typedSymbol
                    .GetAttributes()
                    .Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, zenObjectAttributeSymbol));

                if (hasZenObjectAttribute)
                {
                    var code = SourceText.From(CreateZenCode(typedSymbol), Encoding.UTF8);
                    context.AddSource($"{typedSymbol.Name}Extensions_{typedSymbol.Arity}_zen.cs", code);
                }
            }
        }

        /// <summary>
        /// Create the Zen code for the class.
        /// </summary>
        /// <param name="typeSymbol">The class.</param>B
        /// <returns>The text of the new class to compile.</returns>
        private string CreateZenCode(INamedTypeSymbol typeSymbol)
        {
            var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            var allProperties = GetPropertySymbols(typeSymbol).ToArray();
            var allFields = GetFieldSymbols(typeSymbol).ToArray();
            var typeString = typeSymbol.ToDisplayString();
            var accessModifier = typeSymbol.DeclaredAccessibility.ToString().ToLowerInvariant();
            var genericTypes = typeSymbol.Arity == 0 ?
                string.Empty :
                "<" + string.Join(",", typeSymbol.TypeParameters.Select(x => x.ToDisplayString())) + ">";

            var sb = new StringBuilder();

            sb.AppendLine($"// -------------------------------");
            sb.AppendLine($"// THIS FILE IS AUTOGENERATED");
            sb.AppendLine($"// -------------------------------");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine($"{{");
            sb.AppendLine($"    using ZenLib;");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Extension methods for Zen objects of type {typeSymbol.Name}");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    {accessModifier} static class {typeSymbol.Name}Extensions_zen");
            sb.AppendLine($"    {{");

            // add get methods to access fields
            foreach (var property in allProperties)
            {
                var propertyTypeString = property.Type.ToDisplayString();

                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Get the {property.Name} field for the {typeString} type.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        /// <param name=\"x\">The Zen object.</param>");
                sb.AppendLine($"        /// /// <returns>The {property.Name} field as a Zen value.</returns>");
                sb.AppendLine($"        public static Zen<{propertyTypeString}> Get{property.Name}{genericTypes}(this Zen<{typeString}> x)");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return x.GetField<{typeString}, {propertyTypeString}>(\"{property.Name}\");");
                sb.AppendLine($"        }}");
                sb.AppendLine();
            }

            foreach (var field in allFields)
            {
                var fieldTypeString = field.Type.ToDisplayString();

                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Get the {field.Name} field for the {typeString} type.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        /// <param name=\"x\">The Zen object.</param>");
                sb.AppendLine($"        /// /// <returns>The {field.Name} field as a Zen value.</returns>");
                sb.AppendLine($"        public static Zen<{fieldTypeString}> Get{field.Name}{genericTypes}(this Zen<{typeString}> x)");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return x.GetField<{typeString}, {fieldTypeString}>(\"{field.Name}\");");
                sb.AppendLine($"        }}");
                sb.AppendLine();
            }

            // add with methods to update fields
            foreach (var property in allProperties)
            {
                var propertyTypeString = property.Type.ToDisplayString();

                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Update the {property.Name} field for the {typeString} type.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        /// <param name=\"x\">The Zen object.</param>");
                sb.AppendLine($"        /// <param name=\"field\">The new Zen field value.</param>");
                sb.AppendLine($"        /// /// <returns>The {property.Name} field as a Zen value.</returns>");
                sb.AppendLine($"        public static Zen<{typeString}> With{property.Name}{genericTypes}(this Zen<{typeString}> x, Zen<{propertyTypeString}> field)");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return x.WithField<{typeString}, {propertyTypeString}>(\"{property.Name}\", field);");
                sb.AppendLine($"        }}");
                sb.AppendLine();
            }

            foreach (var field in allFields)
            {
                var fieldTypeString = field.Type.ToDisplayString();

                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Update the {field.Name} field for the {typeString} type.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        /// <param name=\"x\">The Zen object.</param>");
                sb.AppendLine($"        /// <param name=\"field\">The new Zen field value.</param>");
                sb.AppendLine($"        /// /// <returns>The {field.Name} field as a Zen value.</returns>");
                sb.AppendLine($"        public static Zen<{typeString}> With{field.Name}{genericTypes}(this Zen<{typeString}> x, Zen<{fieldTypeString}> field)");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return x.WithField<{typeString}, {fieldTypeString}>(\"{field.Name}\", field);");
                sb.AppendLine($"        }}");
                sb.AppendLine();
            }

            sb.AppendLine($"    }}");
            sb.AppendLine($"}}");

            return sb.ToString();
        }

        /// <summary>
        /// Get the properties for the given class.
        /// </summary>
        /// <param name="classSymbol">The class symbol.</param>
        /// <returns>The property symbols.</returns>
        private IEnumerable<IPropertySymbol> GetPropertySymbols(ITypeSymbol classSymbol)
        {
            return classSymbol
                .GetMembers()
                .OfType<IPropertySymbol>()
                .Where(x => x.SetMethod != null && x.GetMethod != null && x.DeclaredAccessibility == Accessibility.Public && x.CanBeReferencedByName);
        }

        /// <summary>
        /// Get the fields for the given class.
        /// </summary>
        /// <param name="classSymbol">The class symbol.</param>
        /// <returns>The field symbols.</returns>
        private IEnumerable<IFieldSymbol> GetFieldSymbols(ITypeSymbol classSymbol)
        {
            return classSymbol
                .GetMembers()
                .OfType<IFieldSymbol>()
                .Where(x => !x.IsStatic && x.DeclaredAccessibility == Accessibility.Public && x.CanBeReferencedByName);
        }
    }
}